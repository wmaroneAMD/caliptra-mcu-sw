// Licensed under the Apache-2.0 license.

use crate::schema::FuseConfig;
use anyhow::Result;

pub fn generate_fuses(spec: &FuseConfig) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str(stringify!(
        #[derive(Debug, Clone)]
        pub struct Partition {
            pub num: usize,
            pub name: &'static str,
            pub dot: bool,
        }
        #[derive(Debug, Clone, Copy)]
        pub struct Bytes(pub usize);
        #[derive(Debug, Clone, Copy)]
        pub struct Bits(pub usize);
        #[derive(Debug, Clone)]
        pub struct Fuse {
            pub name: &'static str,
            pub size: Bytes,
        }
        #[derive(Debug, Clone)]
        pub struct FuseField {
            pub name: &'static str,
            pub bits: Bits,
        }
    ));

    // Partitions
    output.push_str("pub const PARTITIONS: &[Partition] = &[");
    for partition in spec.partitions.as_ref().unwrap_or(&vec![]) {
        output.push_str(&format!(
            "Partition {{ num: {}, name: \"{}\", dot: {} }},",
            partition.num,
            partition.name,
            partition.dot.unwrap_or(false)
        ));
    }
    output.push_str("];");

    // Secret vendor fuses
    output.push_str("pub const SECRET_VENDOR_FUSES: &[Fuse] = &[");
    for fuse in &spec.secret_vendor {
        for (name, size) in fuse {
            output.push_str(&format!(
                "Fuse {{ name: \"{}\", size: Bytes({}) }},",
                name, size
            ));
        }
    }
    output.push_str("];");

    // Non-secret vendor fuses
    output.push_str("pub const NON_SECRET_VENDOR_FUSES: &[Fuse] = &[");
    for fuse in &spec.non_secret_vendor {
        for (name, size) in fuse {
            output.push_str(&format!(
                "Fuse {{ name: \"{}\", size: Bytes({}) }},",
                name, size
            ));
        }
    }
    output.push_str("];");

    // Fuse fields
    output.push_str("pub const FUSE_FIELDS: &[FuseField] = &[");
    for field in &spec.fields {
        output.push_str(&format!(
            "FuseField {{ name: \"{}\", bits: Bits({}) }},",
            field.name, field.bits
        ));
    }
    output.push_str("];");

    let tokens = syn::parse_file(&output)?;
    let formatted = prettyplease::unparse(&tokens);

    // Prepend the header comments back since prettyplease strips them
    let result = format!(
        "// Licensed under the Apache-2.0 license.\n// Autogenerated file from fuses.hjson. Do not modify this file.\n\n{}",
        formatted
    );

    Ok(result)
}

#[cfg(test)]
mod tests {
    use crate::schema::parse_fuse_hjson_str;

    use super::*;

    #[test]
    fn test_generate_fuses() {
        let example_hjson = r#"
{
  partitions: [
    {num: 10, name: "device_ownership_transfer", dot: true},
    {num: 11, name: "secret_vendor"},
  ],
  // vendor-specific secret fuses
  secret_vendor: [
    {"example_key1": 48}, // size in bytes
    {"example_key2": 48}, // size in bytes
    {"example_key3": 48}, // size in bytes
    {"example_key4": 48}, // size in bytes
  ],
  // vendor-specific non-secret-fuses
  non_secret_vendor: [
    {"example_key_revocation": 1}
  ],
  // TBD how we allow additional fuses outside of these areas, if this is allowed by OTP
  other_fuses: {},
  // entries to define how many bits are in each field, and potentially other information
  fields: [
    // set specifics on Subsystem fuses
    // By default, all bits in each field are assumed to be backed by actual fuse bits.
    // Names should be globally unique
    {name: "CPTRA_SS_OWNER_ECC_REVOCATION", bits: 4}, // size in bits
    // set specifics on vendor-specific fuses
    {name: "example_key_revocation", bits: 4},
  ]
}
"#;

        let config = parse_fuse_hjson_str(example_hjson).unwrap();
        let generated_code = generate_fuses(&config).unwrap();

        println!("Generated code:\n{}", generated_code);

        // The expected output should match what prettyplease generates
        let expected_code = r#"// Licensed under the Apache-2.0 license.
// Autogenerated file from fuses.hjson. Do not modify this file.

#[derive(Debug, Clone)]
pub struct Partition {
    pub num: usize,
    pub name: &'static str,
    pub dot: bool,
}
#[derive(Debug, Clone, Copy)]
pub struct Bytes(pub usize);
#[derive(Debug, Clone, Copy)]
pub struct Bits(pub usize);
#[derive(Debug, Clone)]
pub struct Fuse {
    pub name: &'static str,
    pub size: Bytes,
}
#[derive(Debug, Clone)]
pub struct FuseField {
    pub name: &'static str,
    pub bits: Bits,
}
pub const PARTITIONS: &[Partition] = &[
    Partition {
        num: 10,
        name: "device_ownership_transfer",
        dot: true,
    },
    Partition {
        num: 11,
        name: "secret_vendor",
        dot: false,
    },
];
pub const SECRET_VENDOR_FUSES: &[Fuse] = &[
    Fuse {
        name: "example_key1",
        size: Bytes(48),
    },
    Fuse {
        name: "example_key2",
        size: Bytes(48),
    },
    Fuse {
        name: "example_key3",
        size: Bytes(48),
    },
    Fuse {
        name: "example_key4",
        size: Bytes(48),
    },
];
pub const NON_SECRET_VENDOR_FUSES: &[Fuse] = &[
    Fuse {
        name: "example_key_revocation",
        size: Bytes(1),
    },
];
pub const FUSE_FIELDS: &[FuseField] = &[
    FuseField {
        name: "CPTRA_SS_OWNER_ECC_REVOCATION",
        bits: Bits(4),
    },
    FuseField {
        name: "example_key_revocation",
        bits: Bits(4),
    },
];
"#;

        assert_eq!(generated_code.trim(), expected_code.trim());
    }
}
