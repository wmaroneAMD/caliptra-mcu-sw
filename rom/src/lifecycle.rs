// Licensed under the Apache-2.0 license

use core::fmt::Write;
use mcu_error::{McuError, McuResult};
use registers_generated::lc_ctrl;
use romtime::{HexWord, StaticRef};
use tock_registers::interfaces::{Readable, Writeable};

use crate::fatal_error;

// TODO: fix the autogenerated offsets
// const LC_TOKENS_OFFSET: usize = fuses::SECRET_LC_TRANSITION_PARTITION_BYTE_OFFSET;
pub(crate) const LC_TOKENS_OFFSET: usize = 0x4a0;

/// Unhashed token, suitable for doing lifecycle transitions.
#[derive(Clone, Copy)]
pub struct LifecycleToken(pub [u8; 16]);

impl From<[u8; 16]> for LifecycleToken {
    fn from(value: [u8; 16]) -> Self {
        LifecycleToken(value)
    }
}

impl From<LifecycleToken> for [u8; 16] {
    fn from(value: LifecycleToken) -> Self {
        value.0
    }
}

/// Raw tokens
pub struct LifecycleRawTokens {
    pub test_unlock: [LifecycleToken; 7],
    pub manuf: LifecycleToken,
    pub manuf_to_prod: LifecycleToken,
    pub prod_to_prod_end: LifecycleToken,
    pub rma: LifecycleToken,
}

/// Hashed token, suitable for burning into the OTP.
#[derive(Clone, Copy)]
pub struct LifecycleHashedToken(pub [u8; 16]);

impl From<[u8; 16]> for LifecycleHashedToken {
    fn from(value: [u8; 16]) -> Self {
        LifecycleHashedToken(value)
    }
}

impl From<LifecycleHashedToken> for [u8; 16] {
    fn from(value: LifecycleHashedToken) -> Self {
        value.0
    }
}

/// Hashed tokens to be burned into the OTP for lifecycle transitions.
pub struct LifecycleHashedTokens {
    pub test_unlock: [LifecycleHashedToken; 7],
    pub manuf: LifecycleHashedToken,
    pub manuf_to_prod: LifecycleHashedToken,
    pub prod_to_prod_end: LifecycleHashedToken,
    pub rma: LifecycleHashedToken,
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u8)]
pub enum LifecycleControllerState {
    Raw = 0,
    TestUnlocked0 = 1,
    TestLocked0 = 2,
    TestUnlocked1 = 3,
    TestLocked1 = 4,
    TestUnlocked2 = 5,
    TestLocked2 = 6,
    TestUnlocked3 = 7,
    TestLocked3 = 8,
    TestUnlocked4 = 9,
    TestLocked4 = 10,
    TestUnlocked5 = 11,
    TestLocked5 = 12,
    TestUnlocked6 = 13,
    TestLocked6 = 14,
    TestUnlocked7 = 15,
    Dev = 16,
    Prod = 17,
    ProdEnd = 18,
    Rma = 19,
    Scrap = 20,
    PostTransition = 21,
}

impl core::fmt::Display for LifecycleControllerState {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            LifecycleControllerState::Raw => write!(f, "raw"),
            LifecycleControllerState::TestUnlocked0 => write!(f, "test_unlocked0"),
            LifecycleControllerState::TestLocked0 => write!(f, "test_locked0"),
            LifecycleControllerState::TestUnlocked1 => write!(f, "test_unlocked1"),
            LifecycleControllerState::TestLocked1 => write!(f, "test_locked1"),
            LifecycleControllerState::TestUnlocked2 => write!(f, "test_unlocked2"),
            LifecycleControllerState::TestLocked2 => write!(f, "test_locked2"),
            LifecycleControllerState::TestUnlocked3 => write!(f, "test_unlocked3"),
            LifecycleControllerState::TestLocked3 => write!(f, "test_locked3"),
            LifecycleControllerState::TestUnlocked4 => write!(f, "test_unlocked4"),
            LifecycleControllerState::TestLocked4 => write!(f, "test_locked4"),
            LifecycleControllerState::TestUnlocked5 => write!(f, "test_unlocked5"),
            LifecycleControllerState::TestLocked5 => write!(f, "test_locked5"),
            LifecycleControllerState::TestUnlocked6 => write!(f, "test_unlocked6"),
            LifecycleControllerState::TestLocked6 => write!(f, "test_locked6"),
            LifecycleControllerState::TestUnlocked7 => write!(f, "test_unlocked7"),
            LifecycleControllerState::Dev => write!(f, "dev"),
            LifecycleControllerState::Prod => write!(f, "prod"),
            LifecycleControllerState::ProdEnd => write!(f, "prod_end"),
            LifecycleControllerState::Rma => write!(f, "rma"),
            LifecycleControllerState::Scrap => write!(f, "scrap"),
            LifecycleControllerState::PostTransition => write!(f, "post_transition"),
        }
    }
}

impl core::str::FromStr for LifecycleControllerState {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "raw" => Ok(LifecycleControllerState::Raw),
            "test_unlocked0" => Ok(LifecycleControllerState::TestUnlocked0),
            "test_locked0" => Ok(LifecycleControllerState::TestLocked0),
            "test_unlocked1" => Ok(LifecycleControllerState::TestUnlocked1),
            "test_locked1" => Ok(LifecycleControllerState::TestLocked1),
            "test_unlocked2" => Ok(LifecycleControllerState::TestUnlocked2),
            "test_locked2" => Ok(LifecycleControllerState::TestLocked2),
            "test_unlocked3" => Ok(LifecycleControllerState::TestUnlocked3),
            "test_locked3" => Ok(LifecycleControllerState::TestLocked3),
            "test_unlocked4" => Ok(LifecycleControllerState::TestUnlocked4),
            "test_locked4" => Ok(LifecycleControllerState::TestLocked4),
            "test_unlocked5" => Ok(LifecycleControllerState::TestUnlocked5),
            "test_locked5" => Ok(LifecycleControllerState::TestLocked5),
            "test_unlocked6" => Ok(LifecycleControllerState::TestUnlocked6),
            "test_locked6" => Ok(LifecycleControllerState::TestLocked6),
            "test_unlocked7" => Ok(LifecycleControllerState::TestUnlocked7),
            "dev" | "manuf" | "manufacturing" => Ok(LifecycleControllerState::Dev),
            "production" | "prod" => Ok(LifecycleControllerState::Prod),
            "prod_end" => Ok(LifecycleControllerState::ProdEnd),
            "rma" => Ok(LifecycleControllerState::Rma),
            "scrap" => Ok(LifecycleControllerState::Scrap),
            "post_transition" => Ok(LifecycleControllerState::PostTransition),
            _ => Err("Invalid lifecycle state"),
        }
    }
}

impl From<LifecycleControllerState> for u8 {
    fn from(value: LifecycleControllerState) -> Self {
        match value {
            LifecycleControllerState::Raw => 0,
            LifecycleControllerState::TestUnlocked0 => 1,
            LifecycleControllerState::TestLocked0 => 2,
            LifecycleControllerState::TestUnlocked1 => 3,
            LifecycleControllerState::TestLocked1 => 4,
            LifecycleControllerState::TestUnlocked2 => 5,
            LifecycleControllerState::TestLocked2 => 6,
            LifecycleControllerState::TestUnlocked3 => 7,
            LifecycleControllerState::TestLocked3 => 8,
            LifecycleControllerState::TestUnlocked4 => 9,
            LifecycleControllerState::TestLocked4 => 10,
            LifecycleControllerState::TestUnlocked5 => 11,
            LifecycleControllerState::TestLocked5 => 12,
            LifecycleControllerState::TestUnlocked6 => 13,
            LifecycleControllerState::TestLocked6 => 14,
            LifecycleControllerState::TestUnlocked7 => 15,
            LifecycleControllerState::Dev => 16,
            LifecycleControllerState::Prod => 17,
            LifecycleControllerState::ProdEnd => 18,
            LifecycleControllerState::Rma => 19,
            LifecycleControllerState::Scrap => 20,
            LifecycleControllerState::PostTransition => 21,
        }
    }
}

impl From<u8> for LifecycleControllerState {
    fn from(value: u8) -> Self {
        match value {
            1 => LifecycleControllerState::TestUnlocked0,
            2 => LifecycleControllerState::TestLocked0,
            3 => LifecycleControllerState::TestUnlocked1,
            4 => LifecycleControllerState::TestLocked1,
            5 => LifecycleControllerState::TestUnlocked2,
            6 => LifecycleControllerState::TestLocked2,
            7 => LifecycleControllerState::TestUnlocked3,
            8 => LifecycleControllerState::TestLocked3,
            9 => LifecycleControllerState::TestUnlocked4,
            10 => LifecycleControllerState::TestLocked4,
            11 => LifecycleControllerState::TestUnlocked5,
            12 => LifecycleControllerState::TestLocked5,
            13 => LifecycleControllerState::TestUnlocked6,
            14 => LifecycleControllerState::TestLocked6,
            15 => LifecycleControllerState::TestUnlocked7,
            16 => LifecycleControllerState::Dev,
            17 => LifecycleControllerState::Prod,
            18 => LifecycleControllerState::ProdEnd,
            19 => LifecycleControllerState::Rma,
            20 => LifecycleControllerState::Scrap,
            21 => LifecycleControllerState::PostTransition,
            _ => LifecycleControllerState::Raw,
        }
    }
}

impl From<u32> for LifecycleControllerState {
    fn from(value: u32) -> Self {
        ((value & 0x1f) as u8).into()
    }
}

pub struct Lifecycle {
    registers: StaticRef<lc_ctrl::regs::LcCtrl>,
}

impl Lifecycle {
    pub const fn new(registers: StaticRef<lc_ctrl::regs::LcCtrl>) -> Self {
        Lifecycle { registers }
    }

    pub fn init(&self) -> McuResult<()> {
        romtime::println!("[mcu-lcc] Initializing Lifecycle controller...");
        while !self.registers.status.is_set(lc_ctrl::bits::Status::Ready) {}
        while !self
            .registers
            .status
            .is_set(lc_ctrl::bits::Status::Initialized)
        {}

        romtime::println!(
            "[mcu-lcc] Lifecycle state: {} (count {})",
            HexWord(self.registers.lc_state.get() & 0x1f),
            self.registers.lc_transition_cnt.get()
        );

        romtime::println!("Lifecycle controller initialization done");
        Ok(())
    }

    pub fn status(&self) -> u32 {
        self.registers.status.get()
    }

    pub fn calc_lc_state_mnemonic(state: LifecycleControllerState) -> u32 {
        let state = u8::from(state);
        let next_lc_state_5bit = (state & 0x1F) as u32;

        (next_lc_state_5bit << 25)
            | (next_lc_state_5bit << 20)
            | (next_lc_state_5bit << 15)
            | (next_lc_state_5bit << 10)
            | (next_lc_state_5bit << 5)
            | next_lc_state_5bit
    }

    pub fn transition(
        &self,
        state: LifecycleControllerState,
        token: &LifecycleToken,
    ) -> McuResult<()> {
        romtime::println!(
            "[mcu-rom-lcc] Transitioning Lifecycle state... to {}",
            u8::from(state)
        );
        let next_lc_state_mne = Self::calc_lc_state_mnemonic(state);
        let token = u128::from_le_bytes(token.0);

        const MULTI_TRUE: u32 = 0x96;

        // Step 1: Set Claim Transition Register
        while self.registers.claim_transition_if.get() != MULTI_TRUE {
            self.registers.claim_transition_if.set(MULTI_TRUE);
            let reg_value = self.registers.claim_transition_if.get();
            romtime::println!(
                "[mcu-rom-lcc] Claim Mutex Register: {} (should be {})",
                HexWord(reg_value),
                HexWord(MULTI_TRUE)
            );
        }
        romtime::println!("[mcu-rom-lcc] Mutex successfully acquired.");

        // Step 3: Set Target Lifecycle State
        romtime::println!(
            "[mcu-rom-lcc] Setting next lifecycle state: 0x{:02x}",
            next_lc_state_mne & 0x1f
        );
        self.registers.transition_target.set(next_lc_state_mne);

        // Step 4: Write Transition Tokens
        let token_31_0 = (token & 0xFFFF_FFFF) as u32;
        let token_63_32 = ((token >> 32) & 0xFFFF_FFFF) as u32;
        let token_95_64 = ((token >> 64) & 0xFFFF_FFFF) as u32;
        let token_127_96 = ((token >> 96) & 0xFFFF_FFFF) as u32;

        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_31_0);
        self.registers.transition_token_0.set(token_31_0);
        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_63_32);
        self.registers.transition_token_1.set(token_63_32);
        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_95_64);
        self.registers.transition_token_2.set(token_95_64);
        romtime::println!("[mcu-rom-lcc] Writing tokens: 0x{:08x}", token_127_96);
        self.registers.transition_token_3.set(token_127_96);

        // Step 6: Trigger the Transition Command
        romtime::println!("[mcu-rom-lcc] Triggering transition command: 0x1",);
        self.registers.transition_cmd.set(1);

        // Step 7: Poll Status Register
        loop {
            let status = self.registers.status.extract();
            romtime::println!(
                "[mcu-rom-lcc] Polling status register: {}",
                HexWord(status.get())
            );

            if status.is_set(lc_ctrl::bits::Status::TransitionSuccessful) {
                romtime::println!("[mcu-rom-lcc] Transition successful.");
                break;
            }
            if status.is_set(lc_ctrl::bits::Status::TransitionError) {
                romtime::println!("[mcu-rom-lcc] Transition error detected.");
                fatal_error(McuError::ROM_LC_TRANSITION_ERROR);
            }
            if status.is_set(lc_ctrl::bits::Status::TokenError) {
                romtime::println!("[mcu-rom-lcc] Token error detected.");
                fatal_error(McuError::ROM_LC_TOKEN_ERROR);
            }
            if status.is_set(lc_ctrl::bits::Status::OtpError) {
                romtime::println!("[mcu-rom-lcc] OTP error detected.");
                fatal_error(McuError::ROM_LC_OTP_ERROR);
            }
            if status.is_set(lc_ctrl::bits::Status::FlashRmaError) {
                romtime::println!("[mcu-rom-lcc] FLASH RMA error detected.");
                fatal_error(McuError::ROM_LC_FLASH_RMA_ERROR);
            }
            if status.is_set(lc_ctrl::bits::Status::TransitionCountError) {
                romtime::println!("[mcu-rom-lcc] Transition count error detected.");
                fatal_error(McuError::ROM_LC_TRANSITION_COUNT_ERROR);
            }
            if status.is_set(lc_ctrl::bits::Status::StateError) {
                romtime::println!("[mcu-rom-lcc] State error detected.");
                fatal_error(McuError::ROM_LC_STATE_ERROR);
            }
            if status.is_set(lc_ctrl::bits::Status::BusIntegError) {
                romtime::println!("[mcu-rom-lcc] Bus integrity error detected.");
                fatal_error(McuError::ROM_LC_BUS_INTEG_ERROR);
            }
            if status.is_set(lc_ctrl::bits::Status::OtpPartitionError) {
                romtime::println!("[mcu-rom-lcc] OTP partition error detected.");
                fatal_error(McuError::ROM_LC_OTP_PARTITION_ERROR);
            }
        }

        self.registers.claim_transition_if.set(0);

        romtime::println!("[mcu-rom-lcc] Lifecycle state transitioned");
        Ok(())
    }
}
