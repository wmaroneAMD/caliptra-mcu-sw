// Licensed under the Apache-2.0 license

//! A module for managing interactions with the TbfHeader required to proceed all tock userspace
//! applications.

use std::path::PathBuf;

use anyhow::{anyhow, Result};
use elf::{endian::AnyEndian, ElfBytes};
use tbf_header::TbfHeader;

use crate::manifest::{Binary, Memory};

const BASE_PERMISSIONS: &[(u32, u32)] = &[
    (0, 0), // Alarm
    (0, 1),
    (0, 2),
    (0, 3),
    (0, 4),
    (0, 5),
    (0, 6),
    (1, 0), // Console
    (1, 1),
    (1, 2),
    (1, 3),
    (8, 0), // Low-level debug
    (8, 1), // Low-level debug
    (8, 2), // Low-level debug
    (8, 3), // Low-level debug
];

/// Create a TBF header for the specific TockOS user space application.  This can fail if the
/// application can not be represented within a Header structure due to size.
pub fn create_tbf_header(binary: &Binary) -> Result<TbfHeader> {
    let permissions = BASE_PERMISSIONS.to_vec();

    // If the min ram size is not defined, set it to 0.  This is likely a sizing build, so the
    // minimum ram size is being determined.
    let min_ram_size = binary
        .data_mem
        .as_ref()
        .map(|d| d.size)
        .unwrap_or_default()
        .try_into()?;

    let mut tbf = TbfHeader::new();
    tbf.create(
        min_ram_size,
        0,
        binary.name.clone(),
        None,
        None,
        permissions,
        (None, None, None),
        Some((2, 0)),
        false,
    );
    tbf.set_binary_end_offset(0);
    Ok(tbf)
}

/// Take an initialized tbf header, and generate the bytes to proceed an application binary.
///
/// This could fail if unable to parse the binary to determine application start location.
pub fn generate_tbf_header(
    mut tbf_header: TbfHeader,
    instruction_block: Memory,
    elf: PathBuf,
    binary: PathBuf,
) -> Result<Vec<u8>> {
    // Determine the header and binary size of the application.
    let header_size: u32 = tbf_header.generate()?.get_ref().len().try_into()?;
    let bin_length: u32 = std::fs::metadata(binary)?.len().try_into()?;

    // Parse out the elf, to locate the `start` symbol.  This specifies the start address of the
    // application, which can be used to determine the init function offset within the tbf header.
    let elf_bytes = std::fs::read(&elf)?;
    let elf_file = ElfBytes::<AnyEndian>::minimal_parse(&elf_bytes)?;
    let (symbols, strings) = elf_file
        .symbol_table()?
        .ok_or_else(|| anyhow!("Elf {} does not contain symbol table", elf.display()))?;
    let start_address: u32 = symbols
        .iter()
        .find_map(|symbol| {
            let name = strings.get(symbol.st_name as usize);

            if let Ok("start") = name {
                Some(symbol.st_value)
            } else {
                None
            }
        })
        .ok_or_else(|| anyhow!("Elf {} did not contain start symbol", elf.display()))?
        .try_into()?;

    // The init function offset is the offset from the end of the header to the first instruction
    // to run.
    let init_fn_offset = start_address - (instruction_block.offset as u32) - header_size;

    // Finally calculate the header fields which can only be populated after the binary has been
    // built and populate them.  Then return the generated bytes.
    let total_size = header_size + bin_length;
    tbf_header.set_total_size(total_size);
    tbf_header.set_binary_end_offset(total_size);
    tbf_header.set_init_fn_offset(init_fn_offset);
    tbf_header
        .generate()
        .map(|h| h.into_inner())
        .map_err(|e| e.into())
}
