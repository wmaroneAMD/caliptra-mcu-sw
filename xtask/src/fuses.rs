// Licensed under the Apache-2.0 license

use crate::registers::{file_check_contents, rustfmt, write_file, HEADER_PREFIX, HEADER_SUFFIX};
use anyhow::Result;
use mcu_builder::PROJECT_ROOT;
use registers_generator::snake_case;
use serde::Deserialize;
use std::fmt::Write;
use std::path::Path;

const OTP_CTRL_DEFAULT_PATH: &str = "hw/caliptra-ss/src/fuse_ctrl/data/otp_ctrl_mmap.hjson";
const SPECIFIC_FUSES_DEFAULT_PATH: &str = "hw/fuses.hjson";

const SKIP_PARTITIONS: &[&str] = &[
    "SECRET_MANUF_PARTITION",
    "SECRET_PROD_PARTITION_0",
    "SECRET_PROD_PARTITION_1",
    "SECRET_PROD_PARTITION_2",
    "SECRET_PROD_PARTITION_3",
];

#[derive(Debug, Deserialize)]
struct OtpMmap {
    partitions: Vec<OtpPartition>,
}

#[derive(Debug, Deserialize)]
struct OtpPartition {
    name: String,
    size: Option<String>, // bytes
    secret: bool,
    items: Vec<OtpPartitionItem>,
    desc: String,
    sw_digest: bool,
    hw_digest: bool,
}

#[derive(Debug, Deserialize)]
struct OtpPartitionItem {
    name: String,
    size: String, // bytes
}

/// Autogenerate fuse code.
pub(crate) fn autogen_fuses(
    check: bool,
    dest_dir: &Path,
    fuses_hjson_path: Option<&Path>,
    otp_mmap_hjson_path: Option<&Path>,
) -> Result<()> {
    let file_action = if check {
        file_check_contents
    } else {
        write_file
    };

    // Generate combined output from both functions
    let mut header = HEADER_PREFIX.to_string();

    let mmap_hjson = if let Some(path) = otp_mmap_hjson_path {
        path.to_path_buf()
    } else {
        PROJECT_ROOT.join(OTP_CTRL_DEFAULT_PATH)
    };

    // Generate partition fuses output
    let partition_output = generate_fuse_partitions(&mmap_hjson)?;

    // Generate detailed fuses output if the file exists
    let fuses_hjson = if let Some(path) = fuses_hjson_path {
        path.to_path_buf()
    } else {
        PROJECT_ROOT.join(SPECIFIC_FUSES_DEFAULT_PATH)
    };

    let detailed_output = if fuses_hjson.exists() {
        Some(generate_detailed_fuses(fuses_hjson_path)?)
    } else {
        None
    };

    // Build combined header
    write!(
        &mut header,
        "\n generated by registers_generator with {}",
        mmap_hjson.file_name().unwrap().to_string_lossy(),
    )?;

    if detailed_output.is_some() {
        write!(
            &mut header,
            " and {}",
            fuses_hjson.file_name().unwrap().to_string_lossy()
        )?;
    }

    header.push_str(HEADER_SUFFIX);

    // Combine outputs
    let mut combined_output = partition_output;
    if let Some(detailed) = detailed_output {
        combined_output += "\n";
        combined_output += &detailed;
    }

    // Write combined output to fuses.rs
    let fuses_file = dest_dir.join("fuses.rs");
    file_action(&fuses_file, &rustfmt(&(header + &combined_output))?)?;

    Ok(())
}

/// Autogenerate fuse map code from hjson file used to generate OTP controller config.
fn generate_fuse_partitions(mmap_hjson: &Path) -> Result<String> {
    let otp: OtpMmap = serde_hjson::from_str(std::fs::read_to_string(mmap_hjson)?.as_str())?;
    let mut output = "".to_string();

    output += "use zeroize::Zeroize;\n";
    output += "/// Fuses contains the data in the OTP controller laid out as described in the controller configuration.\n";
    output += "#[derive(Zeroize)]\n";
    output += "pub struct Fuses {\n";
    let mut impl_output = "impl Fuses {\n".to_string();
    let mut default_impl_output = "impl Default for Fuses {\n".to_string();
    default_impl_output += "fn default() -> Self {\n";
    default_impl_output += "Self {\n";
    let mut const_output = "".to_string();
    let mut offset = 0;
    otp.partitions.iter().for_each(|partition| {
        let name = snake_case(&partition.name);
        let digest_size: usize = if partition.hw_digest || partition.sw_digest {
            8
        } else {
            0
        };
        let calculated_size = partition
            .items
            .iter()
            .map(|i| i.size.parse::<usize>().unwrap())
            .sum::<usize>();

        let calculated_size = if digest_size == 8 {
            // digests need to be aligned to 8-byte boundary
            calculated_size.next_multiple_of(8) + digest_size
        } else {
            // partitions need to be aligned to 4-byte boundary
            calculated_size.next_multiple_of(4)
        };

        let size = partition
            .size
            .as_ref()
            .map(|s| s.parse::<usize>().unwrap())
            .unwrap_or(calculated_size);

        if name != "vendor_test_partition" {
            assert_eq!(calculated_size, size);
        }

        if !SKIP_PARTITIONS.contains(&partition.name.as_str()) {
            output += &format!("/// {}\n", &partition.desc.replace("\n", "\n/// "));
            if !partition.secret {
                output += "#[zeroize(skip)]\n";
            }
            output += &format!("pub {}: [u8; {}],\n", name, size);
            default_impl_output += &format!("{}: [0; {}],\n", name, size);

            let mut item_offset: usize = offset;
            partition.items.iter().for_each(|item| {
                let item_name = snake_case(&item.name);
                let item_size = item.size.parse::<usize>().unwrap();
                // digests need to be 8-byte aligned
                if item_name.to_ascii_lowercase().ends_with("digest") {
                    item_offset = item_offset.next_multiple_of(8);
                }
                if item_size == 1 {
                    impl_output += &format!("pub fn {}(&self) -> u8 {{\n", item_name);
                    impl_output += &format!("    self.{}[{}]\n", name, item_offset - offset);
                    impl_output += "}\n";
                } else {
                    impl_output += &format!("pub fn {}(&self) -> &[u8] {{\n", item_name);
                    impl_output += &format!(
                        "    &self.{}[{}..{}]\n",
                        name,
                        (item_offset - offset),
                        (item_offset + item_size - offset)
                    );
                    impl_output += "}\n";
                }
                item_offset += item_size;
            });
            output += "\n";
        }
        const_output += &format!(
            "pub const {}_BYTE_OFFSET: usize = 0x{:x};\n",
            name.to_uppercase(),
            offset
        );
        const_output += &format!(
            "pub const {}_BYTE_SIZE: usize = 0x{:x};\n",
            name.to_uppercase(),
            size,
        );
        offset += size;
    });
    output += "}\n";
    default_impl_output += "}\n}\n}\n";
    impl_output += "}\n";
    output += &impl_output;
    output += &default_impl_output;
    output += &const_output;

    Ok(output)
}

/// Generate more detailed fuse definitions from the MCU-specific file.
fn generate_detailed_fuses(fuses_hjson_path: Option<&Path>) -> Result<String> {
    let fuses_hjson = if let Some(path) = fuses_hjson_path {
        path.to_path_buf()
    } else {
        PROJECT_ROOT.join("hw/fuses.hjson")
    };

    let hjson_content = std::fs::read_to_string(&fuses_hjson)?;
    let config = mcu_fuses_generator::schema::parse_fuse_hjson_str(&hjson_content)?;
    let generated_code = mcu_fuses_generator::codegen::generate_fuses(&config)?;

    Ok(generated_code)
}
